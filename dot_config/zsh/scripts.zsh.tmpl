# -*-mode:bash-*- vim:ft=bash
#
# ~/.config/zsh/scripts.zsh
#
#If debug flag enabled (ZSH_DEBUG = 1), will print file path and name when sourced
[ ! -z "$ZSH_DEBUG" ] && printf "Sourcing file %s (path: %s)\n" "${(%):-%N}" "${(%):-%x}"

screenres() {
    system_profiler SPDisplaysDataType | grep -A2 "Resolution:" | grep "Retina\|Resolution:" | sed -n "${1:-1}p" | awk '{print $2"x"$4}'
}



shell_type="$(ps -p $$ -ocomm=)"

extract() {
    local verbose=false
    local target_dir=""
    local error_log=""
    local exit_code=0
    local here_flag=false
    local OPTIND=1  # Important for bash compatibility with getopts

    # Function to show help
    show_help() {
        cat << 'EOF'
Extract - Universal archive extraction utility

Usage: extract [options] <archive1> [archive2 ...]

Options:
    -h, --help     Show this help message
    -v, --verbose  Enable verbose output
    -d DIR         Extract into specific directory
    --here         Extract in current directory

Supported formats:
    .tar.bz2, .tbz2    tar+bzip2 archives
    .tar.gz, .tgz      tar+gzip archives
    .tar.xz, .txz      tar+xz archives
    .tar               tar archives
    .bz2               bzip2 compressed files
    .gz                gzip compressed files
    .zip, .epub, .cbz  zip archives
    .7z, .apk, .dmg    7zip archives
    .rar, .cbr         rar archives
    .xz                xz compressed files
    .iso               disk images

Examples:
    extract archive.zip                  # Extract to 'archive' directory
    extract --here archive.tar.gz        # Extract to current directory
    extract -d output_dir archive.zip    # Extract to specific directory
    extract -v multiple.zip files.rar    # Extract multiple archives verbosely
EOF
    }

    # Function to check if a command exists - compatible with both shells
    command_exists() {
        command -v "$1" >/dev/null 2>&1
    }

    # Function to log errors - compatible with both shells
    log_error() {
        printf "ERROR: %s\n" "$1" >&2
        error_log="${error_log}ERROR: $1\n"
        exit_code=1
    }

    # Function to get clean directory name - compatible with both shells
    get_extract_dir() {
        local archive="$1"
        local basename
        local dirname

        # Handle basename differently for bash/zsh
        if [ "$shell_type" = "bash" ]; then
            basename=$(basename "$archive")
        else
            basename="${archive:t}"
        fi

        # Remove common archive extensions
        dirname="$basename"
        for ext in ".tar.bz2" ".tar.gz" ".tar.xz" ".tbz2" ".tgz" ".txz" ".tar" \
                  ".bz2" ".gz" ".zip" ".7z" ".rar" ".xz" ".epub" ".cbz" ".cbr" \
                  ".dmg" ".apk" ".iso"; do
            dirname="${dirname%$ext}"
        done
        printf "%s" "$dirname"
    }

    # Parse options - compatible with both shells
    while [ $# -gt 0 ]; do
        case "$1" in
            --help)
                show_help
                return 0
                ;;
            -h)
                if [ "$2" = "--help" ] || [ $# -eq 1 ]; then
                    show_help
                    return 0
                else
                    here_flag=true
                fi
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -d)
                if [ -n "$2" ]; then
                    target_dir="$2"
                    shift 2
                else
                    log_error "No directory specified for -d"
                    return 1
                fi
                ;;
            --here)
                here_flag=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                show_help
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    # Check if any archives were specified
    if [ $# -eq 0 ]; then
        show_help
        return 1
    fi

    # Process each archive
    for archive in "$@"; do
        if [ ! -f "$archive" ]; then
            log_error "'$archive' - file does not exist"
            continue
        fi

        # Get absolute path of archive - compatible with both shells
        local archive_path
        archive_path="$(cd "$(dirname "$archive")" && pwd)/$(basename "$archive")"

        # Determine and create extraction directory
        local current_target_dir="$target_dir"
        if [ "$here_flag" = true ]; then
            current_target_dir="."
        elif [ -z "$current_target_dir" ]; then
            current_target_dir="$(get_extract_dir "$archive")"
            mkdir -p "$current_target_dir" || { log_error "Failed to create directory: $current_target_dir"; continue; }
        fi

        # Save and change directory - compatible with both shells
        local original_dir
        original_dir="$(pwd)"
        if [ "$current_target_dir" != "." ]; then
            cd "$current_target_dir" || { log_error "Failed to change to directory: $current_target_dir"; continue; }
        fi

        [ "$verbose" = true ] && printf "Extracting '%s' to '%s'\n" "$archive" "$(pwd)"

        # Convert to lowercase for case-insensitive matching - compatible with both shells
        local archive_lower
        archive_lower="$(printf "%s" "$archive_path" | tr '[:upper:]' '[:lower:]')"

        # Extract based on file extension
        case "$archive_lower" in
            *.tar.bz2|*.tbz2)
                if command_exists tar; then
                    tar xjf "$archive_path" || log_error "Failed to extract tar.bz2: $archive"
                else
                    log_error "tar is not installed. Install tar first."
                fi
                ;;
            *.tar.gz|*.tgz)
                if command_exists tar; then
                    tar xzf "$archive_path" || log_error "Failed to extract tar.gz: $archive"
                else
                    log_error "tar is not installed. Try: brew install gnu-tar"
                fi
                ;;
            *.tar.xz|*.txz)
                if command_exists tar; then
                    tar xJf "$archive_path" || log_error "Failed to extract tar.xz: $archive"
                else
                    log_error "tar is not installed. Try: brew install gnu-tar"
                fi
                ;;
            *.tar)
                if command_exists tar; then
                    tar xf "$archive_path" || log_error "Failed to extract tar: $archive"
                else
                    log_error "tar is not installed. Try: brew install gnu-tar"
                fi
                ;;
            *.bz2)
                if command_exists bzip2; then
                    bzip2 -dk "$archive_path" || log_error "Failed to extract bz2: $archive"
                else
                    log_error "bzip2 is not installed. Try: brew install bzip2"
                fi
                ;;
            *.gz)
                if command_exists gunzip; then
                    gunzip -k "$archive_path" || log_error "Failed to extract gz: $archive"
                else
                    log_error "gzip is not installed. Try: brew install gzip"
                fi
                ;;
            *.zip|*.epub|*.cbz)
                if command_exists unzip; then
                    $verbose && local v_flag="-v" || local v_flag="-q"
                    unzip $v_flag "$archive_path" || log_error "Failed to extract zip: $archive"
                else
                    log_error "unzip is not installed. Try: brew install unzip"
                fi
                ;;
            *.7z|*.apk|*.dmg|*.iso)
                if command_exists 7z; then
                    7z x "$archive_path" || log_error "Failed to extract 7z: $archive"
                else
                    log_error "7zip is not installed. Try: brew install p7zip"
                fi
                ;;
            *.rar|*.cbr)
                if command_exists unrar; then
                    unrar x -ad "$archive_path" || log_error "Failed to extract rar: $archive"
                elif command_exists unar; then
                    unar "$archive_path" || log_error "Failed to extract rar: $archive"
                else
                    log_error "Neither unrar nor unar is installed. Try: brew install rar or brew install unar"
                fi
                ;;
            *.xz)
                if command_exists unxz; then
                    unxz -k "$archive_path" || log_error "Failed to extract xz: $archive"
                else
                    log_error "xz is not installed. Try: brew install xz"
                fi
                ;;
            *.lzma)
                if command_exists unlzma; then
                    unlzma -k "$archive_path" || log_error "Failed to extract lzma: $archive"
                else
                    log_error "lzma is not installed. Try: brew install xz"
                fi
                ;;
            *.Z)
                if command_exists uncompress; then
                    uncompress -k "$archive_path" || log_error "Failed to extract Z: $archive"
                else
                    log_error "compress is not installed. Try: brew install compress"
                fi
                ;;
            *.cpio)
                if command_exists cpio; then
                    cpio -id < "$archive_path" || log_error "Failed to extract cpio: $archive"
                else
                    log_error "cpio is not installed. Try: brew install cpio"
                fi
                ;;
            *.cab|*.exe)
                if command_exists cabextract; then
                    cabextract "$archive_path" || log_error "Failed to extract cabinet: $archive"
                else
                    log_error "cabextract is not installed. Try: brew install cabextract"
                fi
                ;;
            *.zpaq)
                if command_exists zpaq; then
                    zpaq x "$archive_path" || log_error "Failed to extract zpaq: $archive"
                else
                    log_error "zpaq is not installed. Try: brew install zpaq"
                fi
                ;;
            *)
                log_error "'$archive' - unknown archive method"
                ;;
        esac
		# Return to original directory - compatible with both shells
        cd "$original_dir" || log_error "Failed to return to original directory"
    done

   # Display any errors that occurred - compatible with both shells
    if [ -n "$error_log" ]; then
        printf "\nThe following errors occurred:\n%b" "$error_log"
    fi

    return $exit_code
}

# Create alias - compatible with both shells
alias x='extract'


# Searches history for a string, or lists all history.
# Syntax: `historysearch <string>`
function history_search() {
    if [ -z "$1" ]; then
        history
    else
        history | grep "$1"
    fi
}

# Searches session history for a string, or lists all session history.
# Syntax: `history_session_search <string>`
function history_session_search() {
    prefix=$(date +"$HISTTIMEFORMAT")
    offset=$((8 + ${#prefix}))
    comm -23 <(history | cut -c ${offset}-) "${HISTFILE:-'~/.bash_history'}" | grep "$1"
}

# Creates a directory and changes to it.
# Syntax: `mkcd <directory>`
function mkcd() {
    if [ -z "$1" ]; then
        echo "Usage: mkcd <path>"
        echo "Help: mkcd creates a directory if it doesn't exist, then changes to it."
        return 0
    fi

    mkdir -p -- "$@" && cd -P -- "$_" || exit;
}
alias take=mkcd

# Repeats a command a set number of times.
# Syntax: `repeat <count> <command>`
function repeat() {
    if [ -z "$1" ] || [ "$#" -lt 2 ]; then
        echo "Usage: repeat <count> <command> ..."
        echo "Help: repeat runs a command x number of times."
        return $#
    fi

    local i max
    max=$1; shift;
    for ((i=1; i <= max ; i++)); do
        eval "$@";
    done
}
alias r=repeat

# Sysadmin
# -----------------------------------------------------------------------------

# Keeps all apps and packages up to date.
# Syntax: `update [all]`
function update() {
    if command -v softwarepudate &> /dev/null; then
        echo 'Checking for system updates...'
        softwareupdate -l -i -a
    fi

    if command -v brew &> /dev/null; then
        echo 'Updating packages with Homebrew/Linuxbrew...'
        brew update
        brew upgrade
        brew cask update
        brew cleanup
    fi

    if [[ "$1" == 'all' ]]; then
        if command -v mas &> /dev/null; then
            echo 'Updating App Store applications...'
            mas upgrade
        fi
    fi

    if ! [[ "$OSTYPE" =~ ^darwin ]]; then
        if command -v apt &> /dev/null; then
            echo 'Updating packages with apt...'
            apt update
            apt full-upgrade
            apt autoremove
            apt clean
            apt autoclean
        fi

        if command -v apt-get &> /dev/null; then
            echo 'Updating packages with apt-get...'
            apt-get update
            apt-get upgrade
            apt-get dist-upgrade
        fi
    fi

    if command -v npm &> /dev/null; then
        echo 'Updating Node.js packages with npm...'
        which npm
        npm update -g
    fi

    if command -v npm &> /dev/null; then
        echo 'Updating Ruby gems...'
        which gem
        gem update --system
        gem update
        gem cleanup
    fi
}


# Applications
# -----------------------------------------------------------------------------

# Opens file/URL in Microsoft Edge.
# Syntax: `microsoft-edge <url>`
if [[ "$OSTYPE" =~ ^(cygwin|mingw|msys) ]]; then
    function microsoft-edge() {
        start microsoft-edge:"$1"
    }
fi


# LLM functions
#------------------------------------------------------------------------------
function q {
    # String literal needs to be properly escaped in zsh
    url="$1"
    question="$2"
    content=$(curl -s "https://r.jina.ai/$url")
    system="You are a helpful assistant that can answer questions about the content.
Reply concisely, in a few sentences.
The content:
${content}"
    llm prompt "${question}" -s "${system}"
}

function qv {
    url="$1"
    question="$2"
    
    if ! command -v yt-dlp >/dev/null 2>&1; then
        echo "yt-dlp is required but not found"
        return 1
    fi
    
    subtitle_url=$(yt-dlp -q --skip-download --convert-subs srt --write-sub \
                  --sub-langs "en" --write-auto-sub --print "requested_subtitles.en.url" "$url")
    
    content=$(curl -s "$subtitle_url" | \
              sed '/^$/d' | \
              grep -v '^[0-9]*$' | \
              grep -v '\-->' | \
              sed 's/<[^>]*>//g' | \
              tr '\n' ' ')
              
    system="You are a helpful assistant that can answer questions about YouTube videos.
Reply concisely, in a few sentences.
The content:
${content}"
    
    llm prompt "${question}" -s "${system}"
}


function gcm {
  # Check dependencies
  command -v git >/dev/null 2>&1 || {
    echo "Error: git not found"
    return 1
  }
  
  command -v llm >/dev/null 2>&1 || {
    echo "Error: llm not found"
    return 1
  }

  # Check repository status
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
    echo "Error: Not in a git repository"
    return 1
  }

  git diff --cached --quiet && {
    echo "Error: No changes staged for commit"
    return 1
  }

  # Save IFS
  OLD_IFS="$IFS"
  IFS=$'\n'

  echo "Generating AI-powered commit message..."
  system_prompt=$(cat <<'EOSYSTEM'
  Generate a commit message for the provided git diff with the following guidelines.

  Short (72 chars or less) summary More detailed explanatory text. Wrap it to 72 characters. The blank
  line separating the summary from the body is critical (unless you omit the body entirely).

  Write your commit message in the imperative: "Fix bug" and not "Fixed
  bug" or "Fixes bug." This convention matches up with commit messages
  generated by commands like git merge and git revert.

  Further paragraphs come after blank lines.
  - Bullet points are okay, too.
  - Typically a hyphen or asterisk is used for the bullet, followed by a
    single space. Use a hanging indent.
EOSYSTEM
)

  commit_message=$(git diff --cached | llm --system "$system_prompt")
  
  [ -z "$commit_message" ] && {
    echo "Error: Failed to generate commit message"
    IFS="$OLD_IFS"
    return 1
  }

  while true; do
    printf "\nProposed commit message:\n%s\n" "$commit_message"
    printf "Do you want to (a)ccept, (e)dit, (r)egenerate, or (c)ancel? "
    read -r choice
    
    case "${choice:0:1}" in
      [aA])
        if git commit -m "$commit_message"; then
          echo "Changes committed successfully!"
          IFS="$OLD_IFS"
          return 0
        else
          echo "Error: Commit failed"
          IFS="$OLD_IFS"
          return 1
        fi
        ;;
      [eE])
        printf "Enter your commit message: "
        read -r commit_message
        if [ -n "$commit_message" ] && git commit -m "$commit_message"; then
          echo "Changes committed successfully!"
          IFS="$OLD_IFS"
          return 0
        else
          echo "Error: Commit failed"
          IFS="$OLD_IFS"
          return 1
        fi
        ;;
      [rR])
        echo "Regenerating commit message..."
        commit_message=$(git diff --cached | llm "Generate a concise, descriptive commit message")
        [ -z "$commit_message" ] && {
          echo "Error: Failed to regenerate commit message"
          IFS="$OLD_IFS"
          return 1
        }
        ;;
      [cC])
        echo "Commit cancelled."
        IFS="$OLD_IFS"
        return 1
        ;;
      *)
        echo "Invalid choice. Please try again."
        ;;
    esac
  done
}

function sheet2csv {
  # Check dependencies
  command -v llm >/dev/null 2>&1 || {
    echo "Error: llm not found"
    return 1
  }
  
  # Check if image file is provided
  if [ -z "$1" ]; then
    echo "Usage: sheet2csv <image_file> [output_file.csv]"
    echo "Help: Extracts data from a spreadsheet image into CSV format"
    return 1
  fi
  
  # Check if image file exists
  if [ ! -f "$1" ]; then
    echo "Error: Image file '$1' not found"
    return 1
  fi
  
  # Set output file
  if [ -z "$2" ]; then
    output_file="${1%.*}.csv"
  else
    output_file="$2"
  fi
  
  echo "Extracting data from '$1' using Gemini AI..."
  
  # Create a system prompt for the model
  system_prompt="You are a spreadsheet data extraction assistant. 
Extract all tabular data from the provided image into clean CSV format.
Follow these rules:
1. Preserve the exact structure of the table
2. Include all rows and columns
3. Use commas as delimiters
4. Don't include any explanations or markdown formatting
5. Output ONLY the CSV data, nothing else"
  
  # Process the image with Gemini model using attachment syntax
  csv_data=$(llm "Extract this spreadsheet into CSV format" -m "gemini-2.0-flash" -s "$system_prompt" -a "$1")
  
  if [ -z "$csv_data" ]; then
    echo "Error: Failed to extract data from image"
    return 1
  fi
  
  # Save to file
  echo "$csv_data" > "$output_file"
  
  echo "CSV data extracted and saved to '$output_file'"
  
  # Preview the first few lines
  echo "Preview:"
  head -n 5 "$output_file"
}

function pdf2text {
  # Check dependencies
  command -v llm >/dev/null 2>&1 || {
    echo "Error: llm not found"
    return 1
  }
  
  # Check if PDF file is provided
  if [ -z "$1" ]; then
    echo "Usage: pdf2text <pdf_file> [output_file.txt]"
    echo "Help: Extracts text from a PDF file using Gemini AI"
    return 1
  fi
  
  # Check if PDF file exists
  if [ ! -f "$1" ]; then
    echo "Error: PDF file '$1' not found"
    return 1
  fi
  
  # Check if file is a PDF
  file_type=$(file -b --mime-type "$1")
  if [ "$file_type" != "application/pdf" ]; then
    echo "Error: File '$1' is not a PDF (detected: $file_type)"
    return 1
  fi
  
  # Set output file
  if [ -z "$2" ]; then
    output_file="${1%.*}.txt"
  else
    output_file="$2"
  fi
  
  echo "Extracting text from '$1' using Gemini AI..."
  
  # Create a system prompt for the model
  system_prompt="You are a PDF text extraction assistant.
Extract all text content from the provided PDF document.
Follow these rules:
1. Preserve the document structure as much as possible
2. Include all headings, paragraphs, and important content
3. Maintain the original formatting where appropriate
4. Extract any visible text in tables, charts, or images
5. Output ONLY the extracted text, nothing else"
  
  # Process the PDF with Gemini model
  extracted_text=$(llm "Extract all text from this PDF document" -m "gemini-2.0-flash" -s "$system_prompt" -a "$1")
  
  if [ -z "$extracted_text" ]; then
    echo "Error: Failed to extract text from PDF"
    return 1
  fi
  
  # Save to file
  echo "$extracted_text" > "$output_file"
  
  echo "Text extracted and saved to '$output_file'"
  
  # Preview the first few lines
  echo "Preview:"
  head -n 10 "$output_file"
}
# Development
# -----------------------------------------------------------------------------

# Calls Python's pip3 at the global level.
if command -v pip3 > /dev/null; then
    function gpip3() {
        PIP_REQUIRE_VIRTUALENV="0" pip3 "$@"
    }
fi


# Varia
# -----------------------------------------------------------------------------

# Copies contents to the clipboard.
function cb() {
    if [ -z "$1" ]; then
        echo "Usage: cb <path>"
        echo "Help: cb copies a file contents to the clipboard."
        return 0
    fi

    if command -v pbcopy > /dev/null; then
        pbcopy < "$1"
    elif command -v xclip > /dev/null; then
        xclip -selection clipboard < "$1"
    elif command -v xsel > /dev/null; then
        xsel -ib < "$1"
    elif command -v clipboard > /dev/null; then # node.js clipboard-cli
        clipboard < "$1"
    elif command -v clip > /dev/null; then
        clip < "$1"
    elif command -v powershell > /dev/null; then
        powershell -NoProfile -Command "Set-Clipboard"
    fi
}


{{- if .personal }}
# Lab data sync (config stored in 1Password)
#-------------------------------------------------------------------------------
{{- $targetDir := "" }}{{ $rcloneRemote := "" }}{{ $localFolder := "" }}
{{- range (onepassword "Lab Sync Config").fields }}
{{-   if eq .label "target_dir" }}{{ $targetDir = .value }}{{ end }}
{{-   if eq .label "rclone_remote" }}{{ $rcloneRemote = .value }}{{ end }}
{{-   if eq .label "local_folder" }}{{ $localFolder = .value }}{{ end }}
{{- end }}
function sync_tise2() {
    target_dir="{{ $targetDir }}"
    if [ "$PWD" != "$target_dir" ]; then
        echo "Changing directory to lab folder..."
        cd "$target_dir"
    fi
    rclone copy --drive-shared-with-me -v -M --check-first '{{ $rcloneRemote }}' './{{ $localFolder }}'
}
{{- end }}


# Brewfile management helpers
# -----------------------------------------------------------------------------
_dots_brew() {
    local BREWFILE="${HOME}/.local/share/chezmoi/dot_Brewfile"
    local subcmd="${1:-}"
    [ $# -gt 0 ] && shift

    case "$subcmd" in
        add) _dots_brew_add "$BREWFILE" "$@" ;;
        remove|rm) _dots_brew_remove "$BREWFILE" "$@" ;;
        list|ls) _dots_brew_list "$BREWFILE" "$@" ;;
        *)
            cat << 'EOF'
Usage: dots brew <command> [args]

Commands:
  add <package>     Add package to Brewfile (auto-detects brew/cask)
  remove <package>  Remove package from Brewfile
  list              List packages in Brewfile

Options:
  add --cask        Force cask type (skip auto-detection)
  list --cask       Show only casks
  list --brew       Show only formulas

Examples:
  dots brew add htop         # Add formula (auto-detected)
  dots brew add raycast      # Add cask (auto-detected)
  dots brew add docker --cask  # Force cask
  dots brew remove htop      # Remove from Brewfile
  dots brew list             # List all packages
EOF
            return 1
            ;;
    esac
}

_dots_brew_add() {
    local brewfile="$1"
    shift
    local pkg=""
    local force_cask=false

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --cask) force_cask=true; shift ;;
            -*) echo "Unknown option: $1"; return 1 ;;
            *) pkg="$1"; shift ;;
        esac
    done

    if [ -z "$pkg" ]; then
        echo "Usage: dots brew add <package> [--cask]"
        return 1
    fi

    # Check if already in Brewfile
    if grep -qE "^(brew|cask) \"${pkg}\"" "$brewfile" 2>/dev/null; then
        echo "Package '$pkg' is already in Brewfile"
        return 1
    fi

    local pkg_type=""
    local description=""

    if [ "$force_cask" = true ]; then
        # User forced cask
        if ! brew info --cask "$pkg" >/dev/null 2>&1; then
            echo "Error: Cask '$pkg' not found in Homebrew"
            return 1
        fi
        pkg_type="cask"
        description=$(brew info --cask --json=v2 "$pkg" 2>/dev/null | jq -r '.casks[0].desc // empty')
    else
        # Auto-detect: try cask first (more specific), then formula
        if brew info --cask "$pkg" >/dev/null 2>&1; then
            pkg_type="cask"
            description=$(brew info --cask --json=v2 "$pkg" 2>/dev/null | jq -r '.casks[0].desc // empty')
        elif brew info --formula "$pkg" >/dev/null 2>&1; then
            pkg_type="brew"
            description=$(brew info --formula --json=v2 "$pkg" 2>/dev/null | jq -r '.formulae[0].desc // empty')
        else
            echo "Error: Package '$pkg' not found in Homebrew (tried both formula and cask)"
            return 1
        fi
    fi

    # Build the line to add
    local line
    if [ -n "$description" ]; then
        # Truncate description if too long (keep line under ~80 chars)
        if [ ${#description} -gt 40 ]; then
            description="${description:0:37}..."
        fi
        # Pad to align comments
        local padding=$((26 - ${#pkg} - ${#pkg_type}))
        [ $padding -lt 1 ] && padding=1
        line="${pkg_type} \"${pkg}\"$(printf '%*s' $padding '')# ${description}"
    else
        line="${pkg_type} \"${pkg}\""
    fi

    # Append to Brewfile
    echo "$line" >> "$brewfile"
    echo "Added: $line"
    echo ""
    echo "Next steps:"
    echo "  dots apply     # Sync Brewfile to ~/ and install packages"
    echo "  dots git add . && dots git commit -m 'Add $pkg to Brewfile'"
}

_dots_brew_remove() {
    local brewfile="$1"
    shift
    local pkg="$1"

    if [ -z "$pkg" ]; then
        echo "Usage: dots brew remove <package>"
        return 1
    fi

    # Check if package exists in Brewfile
    if ! grep -qE "^(brew|cask) \"${pkg}\"" "$brewfile" 2>/dev/null; then
        echo "Package '$pkg' not found in Brewfile"
        return 1
    fi

    # Remove the line (handle macOS vs GNU sed, use -E for extended regex)
    if [[ "$(uname)" == "Darwin" ]]; then
        sed -i '' -E "/^(brew|cask) \"${pkg}\"/d" "$brewfile"
    else
        sed -i -E "/^(brew|cask) \"${pkg}\"/d" "$brewfile"
    fi

    echo "Removed '$pkg' from Brewfile"
    echo ""
    echo "Note: Package is still installed. To uninstall:"
    echo "  brew uninstall $pkg"
}

_dots_brew_list() {
    local brewfile="$1"
    shift
    local filter="all"

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --cask) filter="cask"; shift ;;
            --brew|--formula) filter="brew"; shift ;;
            -*) echo "Unknown option: $1"; return 1 ;;
            *) shift ;;
        esac
    done

    if [ ! -f "$brewfile" ]; then
        echo "Brewfile not found: $brewfile"
        return 1
    fi

    case "$filter" in
        cask)
            echo "=== Casks ==="
            grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort
            ;;
        brew)
            echo "=== Formulas ==="
            grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort
            ;;
        all)
            echo "=== Formulas ==="
            grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort
            echo ""
            echo "=== Casks ==="
            grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort
            ;;
    esac
}

# Dotfiles management
# -----------------------------------------------------------------------------
function dots() {
    local CHEZMOI_DIR="${HOME}/.local/share/chezmoi"

    # Show help if no arguments
    if [ -z "$1" ]; then
        cat << 'EOF'
dots - Dotfiles management commands

Usage: dots <command> [args]

Commands:
  apply [-v]     Apply dotfiles to home directory (-v for verbose)
  diff           Show what would change
  status         Show status of managed files
  update         Pull latest changes from remote and apply
  edit [file]    Edit a dotfile (opens source in $EDITOR)
  add <file>     Add a file to be managed by chezmoi
  cd             Change to dotfiles source directory
  git <args>     Run git commands in dotfiles directory
  doctor         Check chezmoi configuration for issues
  data           Show template data (name, email, OS, etc.)
  re-init        Re-run chezmoi init (regenerate config)
  test           Run dotfiles setup tests
  brew <cmd>     Manage Brewfile (add/remove/list packages)
  help           Show this help message

Examples:
  dots apply           # Apply all dotfiles
  dots apply -v        # Apply with verbose output
  dots diff            # Preview changes before applying
  dots edit ~/.zshrc   # Edit zshrc source file
  dots add ~/.somerc   # Start managing a new file
  dots git status      # Check git status of dotfiles repo
  dots git push        # Push dotfiles changes to remote
  dots brew add htop   # Add package to Brewfile
  dots brew list       # List packages in Brewfile
EOF
        return 0
    fi

    local cmd="$1"
    shift

    case "$cmd" in
        apply)
            if [ "$1" = "-v" ] || [ "$1" = "--verbose" ]; then
                chezmoi apply --verbose
            else
                chezmoi apply "$@"
            fi
            ;;
        diff)
            chezmoi diff "$@"
            ;;
        status)
            chezmoi status "$@"
            ;;
        update)
            chezmoi update "$@"
            ;;
        edit)
            if [ -z "$1" ]; then
                # No file specified, open the source directory
                ${EDITOR:-vim} "$CHEZMOI_DIR"
            else
                chezmoi edit "$@"
            fi
            ;;
        add)
            if [ -z "$1" ]; then
                echo "Usage: dots add <file>"
                return 1
            fi
            chezmoi add "$@"
            ;;
        cd)
            cd "$CHEZMOI_DIR" || return 1
            ;;
        git)
            git -C "$CHEZMOI_DIR" "$@"
            ;;
        doctor)
            chezmoi doctor
            ;;
        data)
            chezmoi data
            ;;
        re-init|reinit)
            chezmoi init
            ;;
        test)
            if [ -f "$CHEZMOI_DIR/scripts/test.sh" ]; then
                bash "$CHEZMOI_DIR/scripts/test.sh"
            else
                echo "No test script found at $CHEZMOI_DIR/scripts/test.sh"
                return 1
            fi
            ;;
        brew)
            _dots_brew "$@"
            ;;
        help|--help|-h)
            dots  # Call without args to show help
            ;;
        *)
            echo "Unknown command: $cmd"
            echo "Run 'dots help' for usage information"
            return 1
            ;;
    esac
}

# Tab completion for dots command (zsh)
if [ -n "$ZSH_VERSION" ]; then
    _dots_completion() {
        local -a commands
        commands=(
            'apply:Apply dotfiles to home directory'
            'diff:Show what would change'
            'status:Show status of managed files'
            'update:Pull latest and apply'
            'edit:Edit a dotfile'
            'add:Add a file to chezmoi'
            'cd:Change to dotfiles directory'
            'git:Run git commands in dotfiles repo'
            'doctor:Check chezmoi configuration'
            'data:Show template data'
            're-init:Re-run chezmoi init'
            'test:Run setup tests'
            'brew:Manage Brewfile packages'
            'help:Show help message'
        )

        if (( CURRENT == 2 )); then
            _describe 'command' commands
        elif (( CURRENT == 3 )); then
            case "${words[2]}" in
                edit|add)
                    _files
                    ;;
                git)
                    # Delegate to git completion
                    _git
                    ;;
                apply)
                    _values 'options' '-v[verbose output]' '--verbose[verbose output]'
                    ;;
                brew)
                    local -a brew_cmds
                    brew_cmds=(
                        'add:Add package to Brewfile'
                        'remove:Remove package from Brewfile'
                        'list:List packages in Brewfile'
                    )
                    _describe 'brew command' brew_cmds
                    ;;
            esac
        elif (( CURRENT == 4 )); then
            case "${words[2]}" in
                brew)
                    case "${words[3]}" in
                        add)
                            _values 'options' '--cask[Force cask type]'
                            ;;
                        list)
                            _values 'options' '--cask[Show only casks]' '--brew[Show only formulas]'
                            ;;
                    esac
                    ;;
            esac
        fi
    }
    compdef _dots_completion dots
fi

# =============================================================================
# Useful functions from mathiasbynens/dotfiles
# =============================================================================

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh
    else
        local arg=-sh
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@"
    else
        du $arg .[^.]* ./*
    fi
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
    local port="${1:-8000}"
    sleep 1 && open "http://localhost:${port}/" &
    python3 -m http.server "$port"
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
    local tmpFile="${@%/}.tar"
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
    )

    local cmd=""
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        cmd="zopfli"
    elif hash pigz 2> /dev/null; then
        cmd="pigz"
    else
        cmd="gzip"
    fi

    echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`..."
    "${cmd}" -v "${tmpFile}" || return 1
    [ -f "${tmpFile}" ] && rm "${tmpFile}"

    zippedSize=$(
        stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
        stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
    )

    echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully."
}

# Compare original and gzipped file size
function gz() {
    local origsize=$(wc -c < "$1")
    local gzipsize=$(gzip -c "$1" | wc -c)
    local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l)
    printf "orig: %d bytes\n" "$origsize"
    printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git|node_modules|.venv|__pycache__' --dirsfirst "$@" | less -FRNX
}

# Remove .DS_Store files recursively
function cleanup() {
    find . -type f -name '*.DS_Store' -ls -delete
}

# Empty the Trash on all mounted volumes and the main HDD.
# Also, clear Apple's System Logs to improve shell startup speed.
# Finally, clear download history from quarantine.
function emptytrash() {
    sudo rm -rfv /Volumes/*/.Trashes 2>/dev/null
    sudo rm -rfv ~/.Trash 2>/dev/null
    sudo rm -rfv /private/var/log/asl/*.asl 2>/dev/null
    sqlite3 ~/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV* 'delete from LSQuarantineEvent' 2>/dev/null
    echo "Trash emptied and system logs cleared."
}

# Kill all Chrome tab processes (useful when Chrome is eating CPU)
function chromekill() {
    pgrep -f '[C]hrome Helper --type=renderer' | xargs kill -9
    echo "Chrome renderer processes killed."
}

# =============================================================================
# Cross-shell portable functions (match PowerShell equivalents)
# =============================================================================

# Make directory and cd into it
function mkcd() {
    mkdir -p "$1" && cd "$1"
}
alias take='mkcd'

# Create empty file or update timestamp (touch equivalent)
function touchfile() {
    if [[ -e "$1" ]]; then
        touch "$1"
    else
        > "$1"
    fi
}

# Repeat a command n times
function repeat_cmd() {
    local count=$1
    shift
    for ((i=1; i<=count; i++)); do
        "$@"
    done
}
